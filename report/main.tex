\documentclass[11pt,twoside]{eitExjobb}
\title{Implementing a tool for better obfuscation using overlapping instructions}
%%\documentclass[11pt,twoside,final]{eitExjobb}
% Use final for the final version that will be printed
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%\usepackage[Text,Num]{LUfonts}%% LU fonts (local file)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Nicer fonts
%%\usepackage{pxfonts}
%%\usepackage{mathpazo}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ���

\usepackage[T1]{fontenc}
\usepackage[normalem]{ulem}
%% Packages used in the thesis
\usepackage{color}
\usepackage{graphpap}
\usepackage{cite}
\usepackage{url}
\usepackage{todonotes}
\usepackage{graphicx}
\usepackage{fancyvrb}

\bibliographystyle{alpha}
\unitlength=1mm
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
%%% Title page
\Title{Implementing a tool for better obfuscation using overlapping instructions}
\Author{Erik Nylander\\\texttt{ada09eny@student.lu.se}}
\Date{\today}
\Advisor{Christopher J\"amthagen}
%%\Company{Company\\Address}
\MakeTitlePage
%%%%% Page numbering for front pages
\frontmatter
%%%%% Abstract
\chapter*{Abstract}
The abstract. The abstract. The abstract. The abstract. The
abstract. The abstract. The abstract. The abstract. The abstract. The
abstract. The abstract. The abstract. The abstract. The abstract. The
abstract. The abstract. The abstract. The abstract. The abstract. The
abstract. The abstract. The abstract. The abstract.

%% ToC
\tableofcontents
%\cleardoublepage
%\listoffigures
\listoftables
\cleardoublepage
%%%%% Page numbering for the main thesis
\mainmatter
%%%%%

\chapter{Introduction}
The software buisness is a very competitive field because it is very lucrative in this day and age. In order to generate the biggest revenue, a software company must provide software that goes beyond what products from other companies are doing. To do so, the source code must be exclusive and only known by people inside the company. The alternative is to have source code that is public domain but provide a service to use the code with that no other company can provide. 

Today it is not sufficient to only worry about other companies stealing or copying code, hackers and piracy is a big problem. It is also not sufficient to keep the source code secret only during the development. When a program is ready for release it is built and packaged and the source code is never made public in clear text. However, when a program is released, the built source code is contained in the executable binaries. These binaries are vulnerable because an adversary can use different kinds of disassemblers to go from the binary hexadecimal codes to assembly code. When the assembly code is made visible to the adversery, it can be analyzed and exploited. 

After the release of a program, usually it takes a couple of weeks or sometimes days for a hacker to copy the program and release it on the Internet. It is not unusual for a program to solely rely on license keys in order to make the program usable only to those who has bought it. The way a hacker can exploit this is to disassemble the binary files, find out how the license key is calculated and then write a license key generator that produces a seemingly legitimate serial key and release it to the public so that anyone can use the program without buying it, causing a loss in revenue for the developer.

Anti-disassembly is the art of making a program difficult to disassemble. By utilizing different techniques, a program can be modified so that a disassembler produces erroneus output or no output at all. Several anti-disassembly techniques have been developed and used over the years but the search for better techniques goes on. 

This thesis aims to investigate the use and possibilities of one such technique called \emph{Instruction overlapping}. \emph{Instruction overlapping} exploits the variable length of instructions in the x86 architecture and attempts to hide code inside other code to make a disassembler produce faulty output  while still maintaining the correct behaviour when the program is run. To investigate the practical uses of this technique, a tool will be implemented and tested to determine if \emph{Instruction overlapping} is a viable option for anti-disassembly and also how such a tool could be implemented.


\chapter{Background}
\section{CISC}
CISC (Complex Instruction Set Computer) denotes a series of microprocessor architectures mainly used in personal computers today. When the first CISC processors were launched, memory was expensive so in order to conserve memory space, instructions were designed to take up as little space as possible when used in programs. At the same time, engineers struggled to bridge the semantic gap, meaning the gap between high-level code and assembler code which would allow for better compilers as the assembler code approached high-level functionality. This resulted in a large set of instructions, many of them able to carry out several low level operations such as loading of data from memory, arithmetic instructions and storing of data to memory. In the end, this approach proved to be lacking because it made compilers difficult to implement since there were so many instructions to choose from. Another big problem was that the processors were hard to implement in hardware because the instructions became so complicated. The most important aspects of CISC architectures are as follows:\cite{datorteknik}

\begin{itemize}
\item{An extensive set of instructions to provide a lot of possibilities when coding.}
\item{Powerful instructions performing several low level operations meant to bridge the gap between assembler code and high-level code.}
\item{Instructions of variable length.}
\end{itemize}

\section{RISC}
As the limitations of CISC became more apparent in the 1980s, researchers at University of California at Berkeley and Stanford University started looking for less troublesome, more simple and overall more flexible alternatives. This research resulted in a new type of computer architecture called RISC (Reduced Instruction Set Computer). RISC aimed to make microprocessors easy to implement in hardware and easier to code for by using a much smaller but more straight forward instruction set. The developers of RISC always had the words ``make the common case fast'' in mind while developing. This largely contrasts the way of thinking while developing the older CISC-architecture where the developers aimed to make very powerful and specific instructions in order to make the assembler code more similar to high-level code while using as little memory as possible. The most important aspects of the RISC architecture are the following:

\begin{itemize}
\item{All instructions are of the same length. This makes the instructions easier to decode and it also makes the architecture much simpler to implement in hardware.}
\item{To provide many registers without any special purposes, allowing for variables and temporary calculations to be stored in registers as opposed to being stored in memory resulting in much faster calculations.}
\item{Only certain load and store instructions may access memory. The purpose of this is to reduce the amount of low level operations an instruction can perform which makes more effective use of the ALU while at the same time reducing the complexity of the instructions.}
\end{itemize}

\noindent Even though the RISC architecture had many advantages over CISC, it took a long time for RISC to take its place, mainly because of the lack of software support and the fact that memory was still expensive. Today however, RISC is the most commonly used microprocessor-architecture used overall while CISC still dominates the personal computer-market. Some well known manufacturers of RISC-chips are MIPS, Sun Microsystems(SPARC) and ARM.\cite{datorteknik}

\section{IA-32 architecture}
IA-32 is the third generation of  x86 microprocessor architectures made by Intel. When it was launched in 1985 together with the Intel 80386 microprocessor it was the first 32-bit architecture from Intel, fully backwards compatible with programs made for previous generations of 16- and 8-bit processors. x86 in itself is a CISC architecture which together with the backwards compatibility of IA-32 to its predecessors made for a very complicated platform with an extensive set of instructions with different levels of complexity. Another consequence of this is that the instructions can vary in length from one byte up to fifteen bytes which unintentionally open some interesting possibilities for code obfuscation.. 

With the new 32-bit architecture and Protected Mode, the Intel 80386 could address up to 4 gigabytes of memory. However, when using Protected Mode, all programs are assigned a certain amount of memory to use in order to prevent programs from interfering with each other and any attempt to access memory outside of the allotted amount results in a segmentation fault.

\subsection{The IA-32 instruction set}
Being a CISC architechture, the instruction set for IA-32 contains a very large amount of instructions which can be roughly divided into the following categories:\cite{x86quickguide}\cite{artofassembly} 

\begin{description}
\item[Data movement instructions] Instructions to move data around between memory or registers. 
\item[Arithmetic instructions] These instructions perform arithmetic operations like addition and subtraction.
\item[Logical instructions] Logical instruction perform logical operations such as AND, OR and other bit-operations.
\item[Control flow instructions] These instructions change the control flow of the program.
\item[I/O instructions] I/O instructions gives access to the I/O ports on the processor in order to read data from or write data to peripheral devices.
\item[String instructions] String instructions are used to operate on data in the form of strings of bytes.
\item[Interrupts] Interrupt instructions invoke different kinds of software interrupts in the processor.
\end{description}

\subsection{Looking at an x86 instruction}
The IA-32 instruction format is shown in Table \ref{table:ia32instructionformat}: \\

\begin{table}[h]
\begin{tabular}{|l|l|l|l|l|l|}
\hline
Prefix & Opcode & Mod-Reg-R/M & SIB & Displacement & Immediate \\ \hline
1-4 bytes & 1-2 bytes & 1 byte & 1 byte & 1-4 bytes & 1-4 bytes \\
\hline
\end{tabular}
\caption{The IA-32 instruction format}
\label{table:ia32instructionformat}
\end{table}

\begin{description}
\item[Prefix] This is an optional field used to add prefixes to certain instructions in order to override segment sizes, operand sizes and so on.
\item[Opcode] The opcode consists of 1-2 bytes and is the instruction code that determines the type of instruction. Some instructions contains only of this field.
\item[Mod-Reg-R/M] The Mod-Reg-R/M byte is used in a couple of different ways, mainly to determine if an instruction will access memory or registers. This field will be explained in more detail later.  
\item[SIB] SIB stands for \emph{Scale-Index-Base} and is used to enable index-based addressing of memory. This field will be explained in more detail later.
\item[Displacement] The displacement field is used to access memory with a displacement. If the mod-reg-r/m-byte gives the register that the memory address will be collected from, the displacement field will determine a value to add to the address before accessing the memory.
\item[Immediate] Instructions that uses some kind of immediate value gathers this value from this field instead of picking one from a register or memory.
\end{description}

\subsubsection{The Mod-Reg-R/M byte}
The Mod-Reg-R/M byte consist of three groups of bits that together determines what kind of data that the instruction is accessing, see Table \ref{table:modregrmbyte}. These groups are explained below:\\

\begin{table}[h]
\begin{tabular}{|l|l|l|}
\hline
Mod & Reg & R/M \\
\hline
2 bits & 3 bits & 3 bits \\
\hline
\end{tabular}
\caption{Format of the Mod-Reg-R/M byte}
\label{table:modregrmbyte}
\end{table}


\noindent \uline{Mod}\\
The two \emph{Mod} bits determines if the instruction shall access memory at an address stored in a register and also if a displacement shall be added to the address.\\
\begin{description}
\item[00] The processor will use indirect addressing mode. The address will be collected from the register specified by the r/m bits. Two exceptions are when the r/m field is \emph{100} or \emph{101}.  
\item[01] Indirect addressing mode but an 8-bit displacement will be added to the address before it is dereferenced.
\item[10] Indirect addressing mode but a 32-bit diplacement will be added to the address before it is dereferenced.
\item[11] Direct addressing mode, no memory will be acccessed. Both the reg and r/m fields will denote registers.
\end{description}

\noindent \uline{Reg}\\
The \emph{Reg} field will denote a register: \\ 000 - eax, 001 - ecx, 010 - edx, 011 - ebx, 100 - esp, 101 - ebp, 110 - esi, 111 - edi.\\


\noindent \uline{R/M}\\
The \emph{R/M} field will denote a register just like the reg field. It also denotes the register from which an address will be dereferenced. There are two exceptions to this, namely if the mod bits are 00 and if the r/m bits are 100, then the SIB byte will be used when accessing memory or when the r/m bits are 101, then a displacement value will be dereferenced instead.

\subsubsection{The SIB byte}
The SIB byte like the Mod-Reg-R/M byte also contains three fields of bits called \emph{Scale}, \emph{Index} and \emph{Base}, see Table \ref{table:sibbyte}. As mentioned before, this byte enables index-based memory access. When the SIB byte is used, the address being accessed will be calculated as follows:
$Base + Scale*Index$. The fields in the SIB byte will be explained below:\\

\begin{table}[h]
\begin{tabular}{|l|l|l|}
\hline
Scale & Index & Base \\
\hline
2 bits & 3 bits & 3 bits \\
\hline
\end{tabular}
\caption{Format of the SIB byte}
\label{table:sibbyte}
\end{table}


\noindent \uline{Scale}\\
The two \emph{Scale} bits determines what value the \emph{Index} value will be multiplied with.\\
\begin{description}
\item[00] \emph{Index} will be multiplied by 1.  
\item[01] \emph{Index} will be multiplied by 2.
\item[10] \emph{Index} will be multiplied by 4.
\item[11] \emph{Index} will be multiplied by 8.
\end{description}

\noindent \uline{Index and Base}\\
The \emph{Index} and \emph{Base} fields both denotes registers encoded in the same way as the \emph{Reg} and \emph{R/M} fields in the Mod-Reg-R/M byte. \cite{bittwiddling}\cite{assemblylanguagex86}

\section{Code obfuscation}
Code obfuscation is the action of deliberately making code harder to analyze, interpret and recreate. In the case of machine code, the idea is to make the code hard to disassemble correctly and hard for humans to read and understand once it has been disassembled. The creator of some program can choose to obfuscate their code for a variety of reasons, both benign and malevolent e.g a legitimate programmer may want to hide certain parts of a program, for example which ports the program listens to or the algorithm that determines if a serial code is correct while on the other hand  a hacker might  want to make his virus harder to analyze which could delay the analysis of the virus and the creation of a fix which in turn would let the virus infect a larger number of hosts. By achieving a high level of obfuscation, the risk of a program getting cracked, copied and spread on the internet is greatly reduced. It will also be less susceptible to hacker attacks since an adversary will have a difficult time finding security flaws to exploit.

\subsection{Disassemblers}
There are generally two different kinds of disassemblers namely static disassemblers and dynamic disassemblers. Static disassemblers use either a linear sweep algorithm or a recursive traversal algorithm to decode the instructions in a program. A linear sweep disassembler works in such a way that it reads the program byte after byte, decoding instructions as they come along. A clear advantage with this approach is that the entire program can be disassembled in a single sweep. It is also fairly quick since it only depends on the size of the program. The perhaps most critical disadvantage this approach has is that it does not take the control flow of the program in to account causing it to misinterpret things like data embedded in the stream of instructions.

Recursive traversal disassemblers works such that whenever they encounter a function call or a branch instruction it calculates the possible target address of the instruction, marks the current address as visited and then proceeds to recursively call its disassembler function with the potential target addresses of the current instruction. If it encounters an address that has already been visited, the function returns. This enables the disassembler to avoid interpreting embedded data as executable instructions.

A dynamic disassembler executes the code at the same time as it disassembles the instructions by using an attached debugger, allowing it to follow the control flow of the program by executing branch instructions and function calls. 

Since an analyst can use different kinds of disassemblers, the obfuscator must take the weaknesses of each in account when obfuscating the code in order to achieve a high level of obfuscation to confuse the analyst.

\subsection{Obfuscation techniques}
Over the years, several obfuscation techniques have been invented and employed, ranging from simple tricks to confuse linear sweep disassemblers to sophisticated self modifying code. Some notable approaches will be presented below.

\subsubsection{Junk byte insertion}
This obfuscation technique aims to exploit the weakness of linear sweep disassemblers by embedding data among the executable instructions. Upon disassembly, the disassembler will interpret the junkbyte as the opcode to the start of an instruction, which could cause the following bytes to be interpreted as the rest of the instruction. This would make the program look completely different from the program written without the junkbyte. Note that a recursive traversal disassembler follow the control flow of the program so that it never encounters the junk byte. An example of junk byte insertion is displayed below.\cite{instructionoverlapping}
\\
\\
Consider the following code:
\begin{verbatim}
jmp label               eb 01
db 0x8d                 8d    # junk byte

label:
xor eax, 0x12345678     35 78 56 34 12
int 0x80                cd 80
\end{verbatim}
\noindent After assembling the code above and then using the GNU Assembler \texttt{objdump}\cite{objdump} on it we see that the linear sweep algorithm produces the following code:

\begin{verbatim}
$ objdump -D -b binary -mi386 -M intel example.o
   0:	eb 01                	jmp    0x3
   2:	8d 35 78 56 34 12    	lea    esi,ds:0x12345678
   8:	cd 80                	int    0x80
\end{verbatim}

\noindent Here it is very clear that the linear sweep algorithm in \texttt{objdump} interpreted the data byte 0x8d as the the opcode for the x86 \emph{Load Effective Address} instruction making the disassembled code look different from the code that was actually written. An important thing to note is that the junk byte must be placed so that it will never be reached, potentially causing the program to crash. Another important thing to notice in this example is the fact that the instruction \emph{int 0x80} appears in both code snippets. This is due to the fact that the disassembler tends to synchronize with the correct code in a few instructions (one in this case) because of the variable length of x86 instructions.  

\subsubsection{Opaque predicates}
Opaque predicates is a technique used to fool recursive traversal disassemblers and can be used together with junk byte insertion. The idea is to convert unconditional jump instructions in to conditional jump instructions but make it so that the jump is always taken at runtime. This forces the recursive traversal algorithm to consider both the target as well as the next instruction after the jump. By placing junk bytes directly after the jump instruction, the disassembler can be tricked into producing erroneous code.\cite{instructionoverlapping}

Modifying this technique could also fool a dynamic disassembler. Since a dynamic disassembler will disassemble the code while it is being run, it will only encounter the legitimate code and never reach the junk byte. However, this could be overcome by making the seemingly unconditional jump conditional. This might seem confusing but if one were to make the conditional jump depend on the fact that a debugger was present or not, one could make the jump be not taken if that was the case. Then the dynamic disassembler would be forced to disassemble the junk byte, making it produce faulty code.

\begin{verbatim}
example
\end{verbatim}

\subsubsection{Instruction embedding}
Instruction embedding\cite{instructionembedding} is an interesting obfuscation technique because it effectively hides one or more instructions inside another instruction. An instruction \emph{a} embeds an instruction \emph{b} if the last \emph{x} bytes of \emph{a} consist of all the bytes in \emph{b}. The most important part of any obfuscation technique is to not change the behaviour of the program, luckily, the x86 architecture allows jumps into the middle of an instruction. This means that a jump can be made into the embedding instruction so that the next instruction to be run is actually the embedded instruction.

Since the embedding instruction must be able to contain the entirety of the embedded instruction there are constraints on what instruction can be embedded and which instructions they can be embedded in. The best instructions to use as embedding instructions are those that utilize both a 32-bit displacement value and a 32-bit immediate value, then it will contain 8 bytes that are fully customizable which means that an instruction with the length of 8 bytes can be embedded.

\begin{verbatim}
example
\end{verbatim}



\subsubsection{Using cryptographic hash functions or pseudo-random number generators}
These two approaches both stem from the same idea, namely to generate the code at runtime so that it is never visible to an analyst using a static disassembler. Because the code is generated first when the program is run, it is only present at runtime and only in memory, which means that there is no code to analyze when the program is not being run.

In the case of using pseudo-random number generators, the basic idea is to find a seed \emph{s} to a built-in pseudo random number generator \emph{G} on the host such that a number of consecutive calls to \emph{G} will generate the desired bytes. This is often very hard to do since the probability of finding such a seed is very small, especially as the number of desired bytes grow in size. Because of this the method can be altered by using different kinds of mappings between the generated numbers and the desired bytes.\cite{prng}

When using cryptographic hash functions, the idea is similar. By using some key combined with a salt value together with some cryptographic hash function, a sequence of bytes will be generated. The goal is to find the key, a salt and a hash function such that they together generate the bytes that make up a program. Like the case when using pseudo-random number generators this is very hard to achieve which is why this form of anti-disassembly is rarely used.\cite{chf}

Both of these approaches depend on finding certain values to make them work. The only way to do this is by doing an exhaustive search for suitable values which in turn requires a lot of computing power. If this search space could be divided among a large amount of hosts, time it would take to obtain the desired values would be greatly reduced. An interesting thing to note is that this kind of distributed computing mainly exist in botnets and that a programmer with a botnet at his disposal usually has malevolent purposes in mind. 


\chapter{Instruction overlapping}
\section{Overview}
Instruction overlapping is the obfuscation technique of which the main focus of this thesis lies on. It is similar to instruction embedding in that it hides instructions inside others but it is also more advanced and a more elegant solution. In the case of instruction embedding, an instruction hides another and a jump is needed to execute the hidden instruction. This requires a large amount of jump instructions when a large amount of instructions are hidden which could seem suspisious to an analyser. At the same time, it would not stand a chance against a dynamic disassembler since the control flow of the program is followed and only the instructions executed are disassembled. Instruction overlapping in its simplest form attempts to overcome the former of this problem by making the code look normal. With a bit of tweaking it can also overcome the second problem by making the disassembler execute the non-hidden code.

The main difference between instruction overlapping and instruction embedding is that instruction embedding hides one instruction inside another while in instruction overlapping, several instructions can be hidden inside several others. The main idea is that when looking at a program as a stream of bytes, if the program were to be run starting with the first byte in the stream, one execution path would be executed while if the program were to be run starting at an offset from the first byte, another execution path would be executed. The perfect scenario for this technique would be to have two completely executable paths (non of the executions paths crasches the program) so that the execution path starting at the first byte is the visible code (to the analyst) and the executions path starting at an offset is the hidden code. If this result was achieved, only one jump instruction into the hidded execution path would be needed to run the program as opposed to the case with instruction embedding where serveral jumps were needed. This would make the program look natural and not as suspisious which solves the problem with strange looking code when using instruction embedding.\cite{instructionoverlapping}

\section{Overlapping instructions}


\section{Main Execution Path and Hidden Execution Path} 
As mentioned before, instruction overlapping relies on having two executable paths in one program, the \emph{Main-Executaion-Path}(from here on called MEP) and the \emph{Hidden-Execution-Path}(from here on called HEP). The MEP is the path visible to an analyst and the HEP will consist of the program that is hidden.  






\chapter{Implementation}
\section{Programming Language}
The tool was implemented using C++ with some additional C-libraries. The choice of programming language largely depended on three main factors; speed, flexibility and convenience. C++ was the natural choice because it offers the convenience of the C++ standard libraries which offer good and well implemented container classes and iterators while still maintaning C-like performance.

\section{Main features}
The main features considered for the tool were:

\begin{itemize}
\item{Being able to parsing and represent a program}
\item{Being able to insert one or more bytes before the instructions in the HEP to optain a MEP}
\item{Being able to determine which of the inserted bytes generates the longest and best MEP}
\item{Swapping instructions in the HEP if illegal or unsuitable instructions are found in the correspondig place in the MEP}
\item{Compensating for memory access in the MEP}
\item{Emulate the instructions in the MEP and determine if a jump instruction is legal or not if one is found in the MEP}
\end{itemize}

\noindent All of these features were fully implemented or implemented to an extent in the final product. 

\section{Usage}
The tool was implemented so that a specific input generates an output in the form of a template for the obfuscated program generated from the input.  

\subsection{Input}
The intended input for the tool is a file containing the bytes representing an assembled program. The input file is assumed to be assembled in a way such that only the representation of the instructions are present in the input file, i.e. no code to make the program runable are added when the instructions are assembled.

\subsection{Ouput}
The output of the tools is presented as a template for the obfuscated program that was generated from the input file. It contains aside from the instructions a data section where data is allocated, a preface part and a memory adjusment part. The two latter parts will be explained further on.

\section{Parsing and representing a program}
In order to perform operations on a program it needs to be parsed and represented in some way. This part is done in two steps in the tool, first the input file is read and the bytes are stored in a \texttt{vector}, then the bytes are parsed and stored in \texttt{Instruction} objects. 

Since the parsing and representation of x86 instructions would be very time consuming to implement, two different third party C libraries were used, Udis86 and Libemu. 

\subsection{Udis86}
Udis86 is a disassembler library for x86 written in C. It is used to disassemble a stream of bytes and presenting them result both in hexadecimal byte form aswell as in assembly language. It can disassemble bytes coming from either a byte array or directly from a file. In the tool it is used to read a file and return the bytes and to present the output.\cite{udis}


\subsection{Libemu}
Libemu is a C library used for emulation. It provides the tools to build code analysis programs tailored to specific needs. The library contains an advanced emulator capable of executing a stream of instructions and present the resulting outcome. Alongside the emulator, Libemu offers debugging capabilities.

The tool uses Libemu to parse a stream of bytes and store them in Libemu's internal instruction object. The reason for using an instruction object as opposed to only using the bytes and derive the data necessary from them is that this offers an extra layer of abstraction so that all the instructions can be handled the same way instead of having to utilize ad-hoc style handling for each different type of instruction. The tool wraps the internal instruction object to add some capabilities.\cite{libemu}

\section{"Preface"}
Some instructions are very long, therefore they are difficult to hide. At the same time they often seem to make the MEP sync with the HEP. In order to avoid this behaviour the tool uses a few tricks to substitute these kinds of instructions by moving them out of the HEP and replace them with other instructions that makes the program behave the same but makes the HEP easier to hide. 

After the input file has been read and parsed, a function called \texttt{doPreface()} is called. This functions loops through the instructions and looks for certain kinds of instructions. If one is encountered, it is substituted for one instruction in the Preface part of the program and one instruction in the HEP. How this is done is different for different kinds of instructions.  

\subsection{Workaround for lea instructions}
The \emph{Load Effective Address} or \emph{lea} instruction loads an address and places it in a register. For example: \texttt{lea eax, [somedata]} computes the address of the source operand \texttt{somedata} and stores it in the destination register, \texttt{eax} without actually accessing the memory. 

If the address of \texttt{somedata} in the example above was \texttt{0x12345678}, the instruction would be encoded as follows: \texttt{8d 05 78 56 34 12}. This instruction is the 6 bytes long which can be hard to hide. 

What happens in \texttt{doPreface()} when it encounters a similar \emph{lea} instruction is that it removes the instructions from the HEP. It then proceeds to add a \emph{lea} instruction with the same destination register but with the label of the data minus 1 as the source operand. After that, an ADD instruction adding 1 to the destination register of the \emph{lea} instruction is added to the HEP where the original \emph{lea} instruction was located. For example:

\begin{verbatim}
lea eax, [somedata]
\end{verbatim}

\noindent becomes:

\begin{verbatim}
preface:
	lea eax, [somedata-1]

hep:
	add eax, 1
\end{verbatim}

\noindent The result is that the program behaves like it did prior to the change but the HEP will be easier to hide while the \emph{lea} instruction and the data which address is loaded is somewhat hidden.

The use of a label yields a problem that also affects other parts of the tool. Since the input file is derived from a file written in assembly language, the labels are translated into memory addresses when the file is assembled and because the assembler file is assumed to be assembled without any headers to make the program runable, the address that the label is translated into will not be correct when the output from the tool is run. Because of this, all use of labels has to be done manually after the output has been generated before the obfuscated program can be run.


\section{Generating a MEP}
The first step when generating a MEP from the HEP is to insert one or more bytes before the HEP (from here on called starting bytes) so that a new execution path with overlapping instructions is created. Since the x86 architecture can handle instructions that are up to 15 bytes long, the maximum number of bytes to insert before the HEP is 14. In the tool however, the maximum number of bytes inserted is three. This is mainly because the search space would be too great and the tool would take a very long time to run. 

The choice of starting bytes depends on the instructions in the HEP, therefore all combinations of starting bytes (with some exceptions) are inserted before the HEP and the result is evaluated. Because the x86 provides some instructions with a length in the range of one to three bytes, these starting bytes are discarded since they only generate one instruction and no overlapping occurs. The other types of starting bytes that are discarded are those beginning with \texttt{F6} because of limitations in the implementation of \texttt{libemu}.


\subsection{Input starting bytes}
Since the maximum number of bytes inserted before the HEP is three, all the combinations of one to three bytes are considered which results in a large search space. Before making exceptions all the bytes in the ranges\\ 
\texttt{[0x00 - 0xFF]}, \texttt{[0x0000 - 0xFFFF]}, \texttt{[0x000000 - 0xFFFFFF]} are generated. This brings the number of bytes generated up to $256 + 256^2 + 256^3 = 16843008$ starting bytes. By removing the unsuitable starting bytes the number is reduced to $3316228$ starting bytes.

These different starting bytes are stored in a special object called \texttt{Opcode} and then placed in a \texttt{vector<pair<Opcode, OpcodeMetaData> startingBytes} using the \texttt{pair} class offered by the C++ Standard Library.

After storage, the different starting bytes are inserted before the HEP and evaluated. The different results of the evaluation is stored in the \texttt{OpcodeMetaData} object coupled with the \texttt{Opcode} object. 

\subsection{Looking for the longest MEP}
The first step in the evaluation of the starting bytes is checking the number of instructions before the MEP synchronizes with the HEP. Since the goal is to hide as many instructions as possible, a higher number means a better HEP. The number is calculated for each of the starting bytes by comparing the last instruction in the MEP in the HEP, if they are equal, the last instruction in both execution paths is popped and the process is repeated until the instructions differ. The number of hidden instructions is calculated as follows:

\begin{verbatim}
    Sync number = HEP size - number of equal instructions
\end{verbatim}

The number is then saved in the \texttt{OpcodeMetaData} object for the starting bytes being checked.

After the sync number has been calculated for every \texttt{Opcode} object, the highest sync number is calculated and all starting bytes with a sync number less than the highest are removed.


\subsection{Ranking the starting bytes}
After the starting bytes generating the longest MEP have been found, the evaluation of the remaining starting bytes continues. This part of the evaluation looks more at the actual instructions in the generated MEPS and their characteristics. Starting bytes with MEPs containing undesireable instructions are removed. The different kinds of undesireable instructions are described below.

\subsubsection{Instructions using SIB bytes}
The SIB byte is used for index-based memory access. Firstly, all kinds of memory access in the MEP is undesireable but in some instances they can be remedied by adjusting for memory access which will be explained later. The problem with the use of SIB bytes is that they involve more than one register when calculating the memory address being accessed by the instruction. This means that both of the registers must contain values such that the calculated address is one that the program is allowed to access. This makes further usage of said registers in other registers difficult.

\subsubsection{Interrupts}
The explanation for why interrupting instructions are undesireable in the MEP is simple, they interrup the execution of the program. \\

\noindent Since memory access is a tricky problem to handle it is desired to have as few instructions accessing memory as possible. As a part of the ranking of starting bytes, the number of memory accessing instructions for each of the starting bytes is calculated and saved. The \texttt{OpcodeMetaData} object contains a \texttt{char usedRegs[]} array with eight elements, one for each register. To calculate the number of memory accessing instruction, the tool inserts each of the starting bytes before the HEP again an then loops through the generated MEP. When a memory accessing instruction is found, the register with the memory address being accessed is determined and the corresponding element in the \texttt{usedRegs} array is added by one. The number is then calculated by adding all the numbers in \texttt{usedRegs}. This could have been done without using the \texttt{usedRegs} array by just using an integer to save the number of memory accessing instructions. The reason to why the registers are recorded is that the best possible outcome would be if the registers were only used once or never, then it would not be enough if only the number of memory accessing instructions was used. For example a MEP containing 4 memory accessing instructions where all use different registers is better than a MEP containing only two memory accessing instructions where the same register is used twice.

When instructions using SIB bytes or when interrupting instructions are present in a MEP it can not be used and another MEP must be chosen. If all of the best starting bytes generates MEPs with such instructions then the HEP must be changed in an attempt to overcome this problem. This is done by inserting a \emph{NOP} instruction as the first instruction in the HEP. \emph{NOP} is an instruction that has no effect on the processor other than increasing the program counter. In x86 it is implemented as an \texttt{xchg eax, eax} instruction which does nothing since \emph{xchg} is used to swap the values of two registers. When the \emph{NOP} has been inserted, the process of inserting starting bytes before the HEP is done all over with the original $3316228$ \texttt{Opcode} objects. This is repeated until a MEP without any interrupts or instructions using SIB bytes is found.


\section{Memory access adjusment}
As mentioned before, instructions accessing memory in the MEP needs to be taken care of in order not to crash the program when the MEP is executed. Because there is very little control to be had over the MEP once the proper starting bytes have been choosed, the memory addresses being accessed by certain instructions cannot be changed. Since said addresses can be virtually any number in the range of \texttt{0x00000000 - 0xFFFFFFFF} the probability of a certain address being accessible without rendering a segmentation fault is very, very small and running a MEP without handling this in some way would most likely end up in a crash.  In order to change this behaviour and enable the MEP to run without crashing, the memory addresses that the instructions attempts to access needs to be adjusted for so that they may be accessed without crashing the program. 

In the tool, this is implemented in a fairly simple manor. When the starting bytes have been chosen and the MEP has been generated, the program being operated on resides in two \texttt{vector<Instruction>}'s, namely \texttt{preface} and \texttt{mep}. At this point a new \texttt{vector<Instruction> memoryAdjustment} is created and a function \texttt{adjustForMemoryAccess()} where \texttt{mep} and \texttt{memoryAdjustment} are passed as references is called. In this function, all the instructions accessing memory are found and adjusted for.\\

\noindent When an instruction accessing memory has been found (that has not been adjusted for earlier or affected by a \emph{lea} substitution), the adjustment works like this:
\begin{enumerate}
\item{Determine the register containing the address being accessed}
\item{Make a note to allocate memory for the register}
\item{Construct a \emph{lea} instruction loading the address of the allocated memory in to the register}
\item{Place the \emph{lea} instruction in the \texttt{memoryAdjustment} vector}
\item{If an offset is used before dereferencing the address, constuct an \emph{add} or \emph{sub} instruction using the register and the offset}
\item{Place the \emph{add} or \emph{sub} instruction in the \texttt{memoryAdjustment} vector}
\end{enumerate} 

\noindent For example, if we have the following MEP:
\begin{verbatim}
    add [ecx+0xbb80c46], eax
\end{verbatim}  

\noindent then we would end up with the following code:
\begin{verbatim}
section .data
    dd ecxData 1 				# Allocating one double word with value 1 

section .text

memoryAdjusment:
    lea ecx, [ecxData]			# Loading the address of ecxData into ecx
    sub ecx, 0xbb80c46			# Compensating for the offset

mep:
    add [ecx+0xbb80c46], eax
\end{verbatim}

\noindent When the memory adjustment is done, in the best case scenario, the MEP is able to run and exit without crashing.

\section{Swapping instructions}
In general it is hard to derive a good MEP from any given HEP and it gets harder and harder the longer the HEP is. In some cases it is hard to hide a HEP because it contains long instructions that breaks the MEP by syncing with the HEP. In others it is the sheer volume of the program making the MEP contain a lot of instructions accessing memory which makes the memory adjustment step very difficult. Thankfully, there are a lot of way to do the same thing in x86 which means that one or more instructions can be swapped for other instructions while still maintaining the behaviour of the program. What this means is that if a problematic instruction is found in the MEP, then the instruction in the HEP that spawned the problematic instruction can be swapped. That way the HEP maintains its behaviour and the MEP might get executable without crashing.

\subsection{Swapping 32-bit mov instructions}
The \emph{mov} instruction is used to move data between registers and memory, the possible combinations are listed below:
\begin{itemize}
\item{Register to Register}
\item{Register to Memory}
\item{Memory to Register}
\item{Immediate value to Register}
\item{Immediate value to Memory}
\end{itemize}

\noindent As seen above, it is not possible to move a value from one memory address to another using only one \emph{mov} instruction. When moving a 32 bit value to a register, the instruction length is five bytes which makes the \emph{mov} instruction almost as problematic as the \emph{lea} instructions. Since \emph{mov} is such a regular instruction being used constantly it needs to be handled in some way. There are many instructions which has the same or longer length but the reason for wanting to handle \emph{mov} is that it is often used when invoking Linux system calls\cite{syscall}. System calls are an important part of many programs, they can for example be used for starting other processes, open and write to files or listening to network ports. Needles to say, code invoking system calls is often code that would benefit from being hidden. 

A system call is invoked by putting a system call number in \texttt{eax} and usually some parameters to the system call in the \texttt{ecx, edx, ebx} registers. The system call is then invoked by calling the kernel using an interrupt instruction(\texttt{int 0x80}). This is where the \emph{mov} instruction comes in to the picture. Because numbers are moved to a 32 bit register like \texttt{eax}, 32 bit \emph{mov} instructions are used. This is a problem since there is usually more than one \emph{mov} instruction in a row before the interrupt instruction. One could argue that the corresponding eight bit registers \texttt{al, cl, dl, bl} could be used to avoid moving 32 bit values. However, if there is any number larger than $0xFF$ in the register, the wrong value would reside in the 32 bit register after the eight bit move has been performed since only the least significant bits in the register is changed by the eight bit move.

The way the tool handles 32 bit \emph{mov} instructions is by replacing them with two 16 bit \emph{mov} instructions and a bitwise left shift. The handling is performed like this:

\begin{enumerate}
\item{Move the 16 most significant bits of the 32 bit \emph{mov} instruction into the 16 bit corresponding register}
\item{Shift the 32 bit register 16 steps to the left}
\item{Move the 16 least significant bites of the 32 bit \emph{mov} instruction into the 16 corresponding register}
\end{enumerate}	

\noindent This way we end up with the same value in the register and get rid of the 32 bit \emph{mov}, replacing it with three instructions that are easier to handle. For example, consider the following instruction:
\begin{verbatim}
    mov eax, 0x11112222
\end{verbatim}

\noindent After replacing this instruction we end up with the following instructions:
\begin{verbatim}
    mov ax, 0x1111
    shl eax, 0x10
    mov ax, 0x2222
\end{verbatim} 

\noindent Since it is not always beneficial to replace every 32 bit \emph{mov} instruction, it is optional for the tool to make the substitution or not. Whether or not the substitution shall be made is decided based upon an argument to the tool.

\chapter{Result}
\section{Test programs}
To test the tool, two different test programs were written to be used as input for the tool. The two test programs are desribed below.

\subsection{launchshell}
The functionality of the \texttt{launchshell} program is to open a shell when the program is run. This is done by making a Linux system call called \texttt{sys\_execve} which will execute the program specified by the parameters passed to the system call. The entire program written in assembly language is presented and explained below:

\begin{verbatim}
BITS 32

section .data
    shellpath: db "/bin/sh",0
    shellpathlen: equ $-shellpath
\end{verbatim}

\noindent The first part of the program is the \emph{data section}. Here the string \texttt{shellpath} is allocated and populated with the path to the shell that will be opened. Second, the \texttt{shellpathlen} is allocated and the length of \texttt{shellpath} is placed in it. 

\begin{verbatim}
section .text
    global _start

_start:

    lea esi, [shellpath]                    ; 8d 35 20 00 00 00
    xor eax, eax                            ; 31 c0

    mov dword [esi+shellpathlen], esi       ; 89 76 08
    mov dword [esi+shellpathlen+4], eax     ; 89 46 0c

\end{verbatim}

\noindent Next is the \emph{text section} which contains the executable code. First, the address of the first byte in the \texttt{shellpath} string is loaded into the \emph{esi} register with the \emph{lea} instruction, second, \texttt{xor eax, eax} will effectively replace any value residing in \emph{eax} with zero,vthis will be used later. 

The next two instructions will be used when passing parameters to \texttt{sys\_execve}. The first instruction will place the address of the \texttt{shellpath} string directly after the string itself. The second instruction will place the value of \emph{eax}, namely zero directly after the address in the previous instructions in memory. These use of these two instructions might seem strange but there is a good explaination which will be presented shortly.

\begin{verbatim}
    mov eax, 0xb                            ; b8 0b 00 00 00
    lea ebx, [esi]                          ; 8d e1
    lea ecx, [esi+shellpathlen]             ; 8d 4e 08
    lea edx, [esi+shellpathlen+4]           ; 8d 56 0c
    int 0x80                                ; cd 80
\end{verbatim}

\noindent The final part of the program is the system call. First, the number $0xb$ is placed in \emph{eax}. This is the number identifying \texttt{sys\_execve}. Then the address of the \texttt{shellpath} string is placed in \emph{ebx}. The next step is where the seemingly strange two instructions are explained. \texttt{sys\_execve} takes three parameters, the first one is a pointer to a string containing the path of the program to be started, the second one is a pointer to an array containing arguments to the program being started, by convention, the first argument is the path to the program itself which is why the address of the \texttt{shellpath} string was placed after the string in memory. The next \emph{lea} instruction places the address of the argument in \emph{ecx}. 

The third parameter to \texttt{sys\_execve} is an array of strings which are passed as environment to the executed program. In this case, this parameter is not needed which is why a zero was placed after the argument array in memory. The last \emph{lea} instruction places the address of the zero in the \emph{edx} register.

Lastly the system call is invoked by the interrupt instruction.



\subsection{writetofile}
The next program is called \texttt{writetofile} and like the name suggests, it's functionality is to write data to a file. To do this, two different system calls are used, \texttt{sys\_open} and \texttt{sys\_write}. \texttt{sys\_open} will open a file (or create one provided that certain parameters are used) while \texttt{sys\_write} will write to an open file if permitted. The program is explained below:

\begin{verbatim}
BITS 32

section .data
    textoutput: db 'Hello', 10
    textoutputlen: equ $-textoutput
    filetoopen: db 'hello.txt', 0
\end{verbatim}

\noindent Just like in \texttt{launshell} the first part of the program is dedicated to allocate data. In this program there are three variables allocated, \texttt{textoutput} which is the string that will be written to the file, \texttt{textoutputlen} which is the length of that string and lastly \texttt{filetoopen} which contains the path to the file.

\begin{verbatim}
section .text
global _start

_start:
    mov eax, 0x5                            ; b8 05 00 00 00
    mov ebx, filetoopen                     ; bb 46 00 00 00
    mov ecx, 0x2                            ; b9 02 00 00 00
    int 0x80                                ; cd 80
\end{verbatim}

\noindent The next part of the program is responsible for opening the file. The first instruction moves the number $0x5$ which is the number for \texttt{sys\_open} to \emph{eax}. The second instruction places the address of the \texttt{filetoopen} string in \emph{ebx}. The third instruction the value $0x2$ is placed in \emph{ecx}. This value determines that the file is opened with read and write permissions. Lastly, the system call is invoked by the interrupt instruction.

\begin{verbatim}
    cmp eax, 0                              ; 83 f8 00
    jl exit                                 ; 0f 8c f8 ff ff ff
\end{verbatim}

\noindent When the \texttt{sys\_open} system call has been invoked, the result of the system call is placed in \emph{eax}. If the file does not exist, a negative number is placed in \emph{eax} and if it does exist, the address of the file descriptor is placed in \emph{eax}. 
 
These two instructions are meant to serve as error handling. The first instruction compares if the value in \emph{eax} is bigger than zero and the result of the compared is saved in the \emph{eflags} register. The second instruction then checks the \emph{eflags} register to examine the result, if the value was smaller than zero, the execution will jump to the \texttt{exit} label. Otherwise the execution continues.

\begin{verbatim}
    mov ebx, eax                            ; 89 c3
    mov eax, 0x4                            ; b8 04 00 00 00
    mov ecx, textoutput                     ; b9 40 00 00 00 
    mov edx, textoutputlen                  ; ba 06 00 00 00
    int 0x80                                ; cd 80
\end{verbatim}

\noindent If \texttt{sys\_open} system call was successful, it is now time to write to the file. For this, the system call \texttt{sys\_write} will be used. The first instruction moves the value in \emph{eax} to \emph{ebx}. This is because the address of the file descriptor returned by \texttt{sys\_open} was saved in \emph{eax} and since \emph{eax} is where the system call number is saved, the address of the file descriptor must be moved to \emph{ebx} before the system call number is moved to \emph{eax}. The second instruction does just that. The third and fourth instructions places the address of the \texttt{textoutput} string in \emph{ecx} and the length of the string in \emph{edx}. Lastly the system call is invoked by the interrupt instruction and the string ``hello'' is written to the file.

\begin{verbatim}
 exit:
    mov eax, 1                              ; b8 01 00 00 00 
    mov ebx, 0	                             ; bb 00 00 00 00 
    int 0x80                                ; cd 80
\end{verbatim}

\noindent The last instructions invoke the \texttt{sys\_exit} system call which will terminate the current process. 

\section{Running the tool}
When both of the test programs had been written and tested they were assembled without any headers to make them runnable using \texttt{nasm}\cite{nasm} which is an x86 assembler. The tool was then run twice with each of the test programs as input, once with the substitution of 32 bit \emph{mov} instructions and once without it. Once the tool was finished, the output was copied into an assembly file and the manual allocation of data and the manual part of the memory adjustment was done. After that, both the HEP and the MEP were executed to see if the HEP had the intended behaviour and if the MEP executed without crashing.

The following will be presented in the result:
\begin{description}
\item[Replacing mov] This field shows if the tool was run with 32 bit \emph{mov} substitution or not
\item[Instructions hidden] This field shows the percentage of instructions in the input program that were hidden by the tool. Calculated by dividing the number of instructions in the input program not shown in the ouput by the total number of instructions in the input program.
\item[HEP functional] This field shows if the HEP is functional when the output from the tool is run.
\item[MEP functional] This field shows if the MEP runs without crashing.
\end{description}

\noindent The results for the runs are presented in Table \ref{table:resultslaunchshell} and Table \ref{table:resultswritetofile}.

\begin{table}[h]
\scalebox{0.75}{
\begin{tabular}{l l l l l}
Replacing mov & Instructions hidden(\%) & HEP functional & MEP functional & Starting bytes \\ \hline
Yes & 55.6 & Yes & No & 0xF3 0xF7\\
No & 77.8 & Yes & Yes & 0xF7 0x87 0xFF\\
\end{tabular}}

\caption{Results for \texttt{launchshell}}
\label{table:resultslaunchshell}
\end{table}
\begin{table}
\scalebox{0.75}{
\begin{tabular}{c c c c c}
Replacing mov & Instructions hidden(\%) & HEP functional & MEP functional & Starting bytes \\ \hline
Yes & 14.3 & - & - & 0xF7 0x87 0xFF \\
No & 21.4 & No & No & 0xF7 0x87 0xFF\\
\end{tabular}}

\caption{Results for \texttt{writetofile}}
\label{table:resultswritetofile}
\end{table}


\noindent The output from the tool after the manual work and some finishing for each of the runs are presented below.

\subsection{\texttt{launchshell}}
\subsubsection{With 32 bit mov substitution}

\begin{Verbatim}[fontsize=\tiny]
BITS 32
section .data

    shellpath: db "/bin/sh",0
    shellpathlen: equ $-shellpath

    ebxData: dd 1
    eaxData: dd 1

section .text
    global _start

_start:
;preface
    lea esi, [shellpath-1]

;Memory adjustment
    lea ebx, [ebxData]
    add ebx, 0x3fcefe3a
    lea eax, [eaxData]
    sub eax, 0x0

    jmp mep0 + 0x2


mep0:
    repe test dword [ebx-0x3fcefe3a], 0x89087689        ; f3 f7 83 c6 01 31 c0 89 76 08 89
    inc esi                                             ; 46
    or al, 0x66                                         ; 0c 66 
    mov eax, 0xe0c10000                                 ; b8 00 00 c1 e0
    adc [esi-0x48], ah                                  ; 10 66 b8
    or eax, [eax]                                       ; 0b 00
    lea ebx, [esi]                                      ; 8d 1e
    lea ecx, [esi+0x8]                                  ; 8d 4e 08
    lea edx, [esi+0xc]                                  ; 8d 56 0c
    int 0x80                                            ; cd 80
    mov eax, 1                                          ; b8 10 00 00 00
    mov ebx, 0                                          ; bb 00 00 00 00
    int 0x80                                            ; cd 80
\end{Verbatim}

\noindent When looking at the code it is clear that it looks very different from input program. The \emph{data section} is very similar with the addition of \texttt{ebxData} and \texttt{eaxData} which are used for memory adjustment. Next is the preface where the \emph{lea} instruction in the input program has been replaced and after that is the memory adjustmen part where the \emph{ebx} and \emph{eax} registers are populated and the offsets are compensated for. Now for the really interesting part, after the \emph{jmp} instruction the actual MEP is shown. Compairing it to the input program, the code looks very different. It is not until the \texttt{lea ebx, [esi]} instruction that the MEP has synced with the HEP and the code looks the same as in the input program. This means that the tool has been able to hide five of the nine instructions in the input program.

\subsubsection{Without 32 bit mov substitution}
\begin{Verbatim}[fontsize=\tiny]
BITS 32
section .data

    shellpath: db "/bin/sh",0
    shellpathlen: equ $-shellpath

    ediData: dd 1
    ecxData: dd 1
    eaxData: dd 1
    ebpData: dd 1

section .text
    global _start
_start:
;preface
    lea esi, [shellpath-1]

;Memory adjustment stuff 
    lea edi, [ediData]
    sub edi, 0x1c683ff
    lea ecx, [ecxData]
    sub ecx, 0xbb80c46
    lea eax, [eaxData]
    sub eax, 0x0
    push ebp
    lea ebp, [ebpData]
    sub ebp, 0x84e8d1e

    jmp mep0 + 0x3

;mep
mep0:
    test dword [edi+0x1c683ff], 0x7689c031              ; f7 87 ff 83 c6 01 31 c0 89 76     
    or [ecx+0xbb80c46], cl                              ; 08 89 46 0c b8 0b
    add [eax], al                                       ; 00 00
    add [ebp+0x84e8d1e], cl                             ; 00 8d 1e 8d 4e 08
    lea edx, [esi+0xc]                                  ; 8d 56 0c
    int 0x80                                            ; cd 80
    pop ebp                                             ; 5d
    mov eax, 1                                          ; b8 01 00 00 00
    mov ebx, 0                                          ; bb 00 00 00 00
    int 0x80                                            ; cd 80
\end{Verbatim}

\noindent This output is similar to the previous one, the memory adjustment part is a little different since this output uses other registers for memory access. The \emph{lea} substitution in the preface is the same. The real difference is in the MEP where it is not until the \texttt{lea edx, [esi+0xc]} that the MEP synchronizes with the HEP. Compairing this output to the input program, seven of the nine instructions have been hidden by the tool.

\subsection{\texttt{writetofile}}
\subsubsection{With 32 bit mov substitution}
\begin{Verbatim}[fontsize=\tiny]
BITS 32
section .data

    textoutput db 'Hello', 10
    textoutputlen equ $ - textoutput
    filetoopen db 'hello.txt', 0

    ediData: dd 1
    esiData: dd 1


section .text
    global _start
_start:
;preface

;Memory adjustment 
    lea edi, [ediData]
    add edi, 0x47996f01
    lea esi, [esiData]
    add esi, 0x48

    jmp mep0 + 0x3

;mep
mep0:
    test dword [edi-0x47996f01], 0xe0c10000             ; f7 87 ff 90 66 b8 00 00 c1 e0
    adc [esi-0x48], ah                                  ; 10 66 b8
    add eax, 0xbb6600                                   ; 05 00 66 bb 00
    add cl, al                                          ; 00 c1
    jecxz 0x28c31de8                                    ; e3 e7
    mov bx, 0x46                                        ; 66 bb 46 00
    mov cx, 0x0                                         ; 66 b9 00 00
    shl ecx, 0x10                                       ; c1 e1 10
    mov cx, 0x2                                         ; 66 b9 02 00
    int 0x80                                            ; cd 80
    cmp eax, 0x0                                        ; 83 f8 00
    jl 0x28c31dea                                       ; 0f 8c e6 1d c3 28
    mov ebx, eax                                        ; 89 c3
    mov ax, 0x0                                         ; 66 b8 00 00
    shl eax, 0x10                                       ; c1 e0 10
    mov ax, 0x4                                         ; 66 b8 04 00
    mov cx, 0x0                                         ; 66 b9 00 00
    shl ecx, 0x10                                       ; c1 e1 10
    mov cx, 0x40                                        ; 66 b9 04 00
    mov dx, 0x0                                         ; 66 ba 00 00 
    shl edx, 0x10                                       ; c1 e2 10
    mov dx, 0x6                                         ; 66 ba 06 00
    int 0x80                                            ; cd 80
    mov ax, 0x0                                         ; 66 b8 00 00
    shl eax, 0x10                                       ; c1 e0 10
    mov ax, 0x1                                         ; 66 b8 01 00
    mov bx, 0x0                                         ; 66 bb 00 00
    shl ebx, 0x10                                       ; c1 e3 10
    mov bx, 0x0                                         ; 66 bb 00 00
    mov eax, 1                                          ; b8 01 00 00 00
    mov ebx, 0                                          ; bb 00 00 00 00
    int 0x80                                            ; cd 80
\end{Verbatim}

\noindent When running the tool with \texttt{writetofile} as input and using 32 bit \emph{mov} substitution, the output is on the same format as the runs with \texttt{launchshell}. The \emph{data section} looks similar, the variables from the input program are allocated together with the data for memory adjustment. The MEP is a little harder to interpret since the 32 bit \emph{mov} substitution has changed the look of the program. Upon assembly of the input program, the label in the instruction \texttt{mov ebx, filetoopen} has been translated into \texttt{mov ebx, 0x46}. Knowing this, it can be determined that the tool only managed to hide two of the instructions in the input program. 

An interesting thing to note is that while the output looks completely different from the input program, it is not hidden, this is simply the work of the 32 bit \emph{mov} sustitution which does not mean that the program is obfuscated since it is still easy to see what the program does.

\subsubsection{Without 32 bit mov substitution}
\begin{Verbatim}[fontsize=\tiny]
BITS 32
section .data

    textoutput db 'Hello', 10
    textoutputlen equ $ - textoutput
    filetoopen db 'hello.txt', 0

    ediData: dd 1
    eaxData: dd 1
    ecxData: dd 1


section .text
    global _start
_start:
;preface

;Memory adjustment
    lea edi, [ediData]
    sub edi, 0x5b890ff
    lea eax, [eaxData]
    sub eax, 0x0
    lea ecx, [ecxData]
    sub ecx, 0x2

    jmp mep0 + 0x3

;mep
mep0:
    test dword [edi+0x5b890ff], 0xbb000000              ; f7 87 ff 90 b8 05 00 00 00 bb
    inc esi                                             ; 46
    add [eax], al                                       ; 00 00 
    add [ecx+0x2], bh                                   ; 00 79 02
    int 0x80                                            ; cd 80
    cmp eax, 0x0                                        ; 83 f8 00
    jl 0x2d6d57e9                                       ; 0f 8c e5 57 6d 2d 
    mov ebx, eax                                        ; 89 c3
    mov eax, 0x4                                        ; b8 04 00 00 00
    mov ecx, 0x40                                       ; b9 40 00 00 00 
    mov edx, 0x6                                        ; ba 06 00 00 00
    int 0x80                                            ; cd 80
    mov eax, 0x1                                        ; b8 01 00 00 00
    mov ebx, 0x0                                        ; bb 00 00 00 00
    int 0x80                                            ; cd 80
\end{Verbatim}

\noindent The format of this output is the same as for the others. Looking at the MEP it is by the \texttt{int 0x80} instruction that the MEP has synchronized with the HEP. This means that the almost the entire first system call has been hidden. The number of hidden instructions is for this run three.\newline

\noindent Another interesting observation is that the tool chose the starting bytes \texttt{0xF7 0x87 0xFF} for both of the \texttt{writetofile} runs aswell as for one of the \texttt{launchshell} runs even though they contain different instructions. 

\chapter{Discussion and further development}

\section{Observations regarding \texttt{launchshell}}
As shown in the \emph{Result} section, the tool was most successful when obfuscating this program, both with and without the 32 bit \emph{mov} substitution. Interestingly enough, the best result was achieved without the 32 bit \emph{mov} substitution. Reaching a 77.8\% level of obfuscation while still being able to run both the MEP and the HEP is a very good result. It is not a perfect result since the last 22.2\% could potentially contain sensitive code. There are a few potential remedies for this problem that will be discussed in the \emph{Further development} section. 

Running the tool with this input program with the 32 bit \emph{mov} substitution achieved a 55.6\% level of obfuscation which is still pretty good. While the HEP was able to run and actually start a shell the MEP crashed. The reason for the crash is that the \texttt{or eax, [eax]} instruction tried to access memory that it was not allowed to. Even though the memory access of the address in \emph{eax} had been adjusted for, two instructions before the \texttt{or eax, [eax]} instruction had changed the value of \emph{eax}. This is a weakness in the memory adjustment part of the tool.


\section{Observations regarding \texttt{writetofile}}
While the tool achieved fairly good results when obfuscating \texttt{launchshell}, attempting to obfuscate \texttt{writetofile} was a different story. Not only did the tool only manage to hide at most 21.4\% of the program, which in this case is only three instructions, none of the obfuscated programs worked as intended. 

The output generated when obfuscating the program without the 32 bit \emph{mov} substitution managed to run and the HEP even managed to run without crashing. However, even though the HEP ran, it did not work as intented, it did not write ``Hello" to the file. The reason for this is that when assembling the instructions in the output, \texttt{nasm} chose a different encoding of the \texttt{add [ecx+0x2], bh} instruction in the MEP, resulting in the wrong behaviour in the HEP. The instruction \texttt{add [ecx+0x2], bh} was encoded as \texttt{[00 79 02]} instead of \texttt{[00 b9 02 00 00 00]} as the tool intended. Both of the encodings are correct, both \emph{Udis} and \texttt{objdump} recognizes \texttt{[00 b9 02 00 00 00]} as \texttt{add [ecx+0x2], bh}. When the HEP is run, instead of placing the correct value in \emph{ecx} using \texttt{mov ecx, 0x2}(\texttt{[b9 02 00 00 00]}),  the instruction \texttt{jns 0xf} (\texttt{79 02}) is executed. \emph{jns} is short for \emph{jump not signed} and does a relative jump if the \emph{sign} flag is not set. Because the \emph{sign} flag is not set on this occasion, the jump is taken and the interrupt instruction invoking the system call is skipped. This problem is discussed further under \emph{Known problems}.

The reason for the crash of the MEP is an issue that arise when labels are used. When a program containing labels is assembled, the labels are translated into memory addresses, for example \texttt{jmp exit} could be translated into \texttt{jmp 0x80902342}. The problem is that when the program is assembled without any headers to make it runnable, the memory address for the label is different from when the program is assembled with headers. When the assembled program is parsed by the tool, the labels have already been translated. The tool can then only operate on the bytes that are available to it. This means that if a label is used in the input program, the corresponding memory address will be present in the obfuscated program. Since this memory address is different from the one that would be used if the input program was runnable, if it were to be used in the HEP, this would result in a crash. 

By time the execution has reached the \texttt{int 0x80} instruction, the number in \emph{eax} is not related to any system call. Because of this, when the interrupt instruction is executed, a negative number is placed in \emph{eax}. Since there is a \texttt{jl exit} instruction in the HEP depending on whether the value in \emph{eax} is smaller than zero and the MEP has synced with the HEP by this time, the jump is taken, causing a segmentation fault because the program is not allowed to access the memory address in the jump instruction. 

When obfuscating \texttt{writetofile} with the 32 bit \emph{mov} substitution the situation grew even more bleak. Only two instructions (actually only one and a half because of the \emph{mov} substitution) was hidden. On top of that the program could not be run because it could not be linked to be executable. \texttt{nasm} was able to assemble the program but \texttt{ld}\cite{ld} could not link it and produced an error message instead. The cause of this problem is the \texttt{jecxz 0x28c31de8} instruction which will be discussed in \emph{Known problems}.

\section{Known problems}
These are some problem discovered during the implementation of the tool. They will be explained below and in some cases potential solutions will be suggested.

\subsection{The label problem}
The problem with labels has been touched on already in previous sections. It is a big problem since it involves all uses of labels Since this breaks the behaviour of the HEP and in most cases results in a segmentation error causing the program to crash it is a big problem that needs a solution. 

One solution could be to use a file assembled together with headers to make it runnable, where the labels have been translated into correct memory addresses as input to the tool. The tool would then have to ignore the instructions having to do with the headers and find the instructions that needs to be hidden. Then the tool could perform the same operations as it does currently but hopefully without the label problem. 

\subsection{Errors caused by jecxz}


\subsection{Weaknesses in memory adjustment}
As mentioned several times before, memory adjustment is a difficult problem. Sometimes the memory adjustment in the tool is sufficient to make a MEP execute without crashing but for the most part there are issues. Currently when memory is adjusted for, only one memory accessing instruction using a specific register is considered. In some cases more than one instruction tries to access memory using the same register which in the current implementation is ignored. On top of that, anything can happen to the register between the memory adjustment and the actual instruction that was adjusted for. 

The problem with instructions between the memory adjustment and the instruction that was adjusted for could be counteracted by taking the in-between instruction into account when calculating what value that needs to be in the register for the memory accessing instruction to execute properly. 

When it comes to several instructions using the same register for memory access, the situation is a bit more complicated. One solution could be to have a memory adjustment part for each of the memory accessing instructions. That way a conditional jump instruction to the memory adjustment part could be inserted in the MEP. In order no to break the behaviour of the HEP, the condition would be if the MEP is supposed to run or not. This of course means that the MEP has to be made to synchronize with the HEP before each of the problematic memory adjustment parts using for example \emph{nop} instructions. This solution is related to the \emph{Having more than one MEP} part in the \emph{Further development} section. 

\subsection{Wrong encodings when assembling}
In the x86 architecture, one instruction can have several different encoding. This is unfortunate because when the tool produces its output, it expects the instructions to be encoded using the same bytes that it uses when the output is assembled. 

If however there is a difference between the encoding used in the tool and the one used by \texttt{nasm} the MEP looks like it is supposed to but the HEP will contain the wrong instructions which is a huge problem.

One potential solution would be to not rely on \texttt{nasm} and print the bytes directly to a file. This ensures that the correct encoding is used. However, to make the output program runnable, headers would have to be added which would complicate the process immensely. 

\section{Further development}
In the following sections are some suggestions for improvements in the tool to make it better and less prone to unsuccesful obfuscations.

\subsection{Choosing starting bytes}
Currently, when the tool chooses starting bytes, first it removes all starting bytes that did not generate the longest possible MEP, it then proceeds to remove the starting bytes with the most memory accessing instructions and then it chooses the last \texttt{Opcode} object in the list of starting bytes to act as the actual starting bytes for the MEP. There are a few problems with this approach that will be discussed below.

To obtain the best possible MEP, all possible starting bytes would have to be tested with all possible variations of the input program. Variations of the input program could be swapping one instruction at a time, maybe several times if several alternatives to the instruction exists. Then every one of the generated MEPs could be checked for problems and the best ones could be picked out. However, this is not an approach that is computionally feasible, it would take an enormous amount of time to test all combinations. This is why the number of bytes in the starting bytes has been limited to three.

The next problem is regarding choosing starting bytes based upon the number of memory accessing instructions. As mentioned in the \emph{Implementation} section, a MEP containing three memory accessing instruction using three different registers is better than a MEP with only two memory accessing instructions that uses the same register. This is one of the most important improvements that could be made to the tool since it could greatly reduce the number of problems regarding memory adjustment.

\subsection{Having more than one MEP}
In some programs it is difficult to find starting bytes that can hide a lot of instructions. This problem becomes even bigger as the size of the input program grows. Since obfuscating only a portion of a program could be a complete waste of time if the entirety of the input program contains sensitive instructions this is also a big problem and one of the biggest challenges when using instruction overlapping.

One possible solution to this problem could be to have more than one MEP. This could work in such a way that if the MEP synchronizes with the HEP after an insufficient amount of instructions, the tool could insert a new jump instruction and new starting bytes so that an additional MEP is created. This would effectively hide an additional portion of the program and it would do so without compromising the behaviour of the HEP since it would only cause a jump into the next instruction of the HEP. Of course the problem with finding the best starting bytes and memory adjustment would have to be dealt with again.

The memory adjustment could be done so that there was a memory adjustment section for each MEP in the output program. Then when one MEP ended, the execution would jump to the memory adjustment section for the next MEP in line where all the memory accessing instruction in that MEP would be adjusted for. In order to not change the behaviour of the HEP, this could be made so that the jump to the memory adjustment section would only be taken if the MEPs were to be executed. 

\subsection{Substituting instructions on demand}
When encountering problematic instructions in the MEP, currently the tool tries to pick other starting bytes in an attempt to get rid of the problematic instructions. If none of the starting bytes produce a satisfying MEP, the tool adds a one byte \emph{nop} instruction before the HEP and the process of choosing starting bytes is started all over again. Not only does this make the runtime of the tool a lot longer but there is also no guarantee that it will find a suitable MEP.

A far better solution would be to replace instructions in the HEP if they cause problems in the MEP. Currently, the tool can substitute 32 bit \emph{mov} instructions by using 16 bit \emph{mov} instructions and a logical shift instruction. The problem with the current implementation is that it can only replace 32 bit \emph{mov} instructions and only does so by replacing all of them at once.

This is an area in the tool that could be expanded which would contribute immensely to finding good MEPs. The way this would work is that when a problematic instruction is found in the MEP, the tool finds the instruction in the HEP the makes up the problematic instruction and replace it with some other instruction(s). This could be used to get rid of all kinds of instructions and if needed avoid difficult memory adjustments. Thankfully there are a lot of ways to do the same thing in x86. 

\subsection{Adding code to fool dynamic disassemblers}
A very important feature when using instruction overlapping is being able to determine if the MEP or HEP is to be executed. Because the MEP is only supposed to be executed when the program is being analysed. Since this is often done using a dynamic disassembler in a virtual machine. Thankfully there are ways to determine if a program is run on a virtual machine and whether a debugger is attached.

If code for detecting a debugger or if the program was run on a virtual machine was added to the program, the execution of the MEP could be made to depend on that fact. This could should of course be provided by the tool.

\subsection{Taking advantage of the emulator}
\texttt{libemu} was first considered for the tool because of it emulation capabilities, however the tool does not use the emulator at all. 

The primary use of the emulator, would be if a conditional jump instruction was found in the MEP. Then the instructions prior to the jump instruction could be emulated and the tool could inspect the \emph{eflags} register to determine if the jump would be taken. If that would be the case, the instruction in the HEP generating the jump in the MEP would have to be replaced. If not, the jump would be allowed to stay in the MEP since it would not compromise the control flow of the program.

Another less obvious use could be to help with instruction substitution. As mentioned in the \emph{Implementation} section, instead of using 32 bit \emph{mov} instructions when moving values smaller than \texttt{0xFF}, eight bit \emph{mov} instructions could be used instead. The problem with this approach was that if a larger value than \texttt{0xFF} already was in the register, the wrong value would reside in the register since the eight bit \emph{mov} only would affect the least significant part of the register. The emulator could be used to emulate all the instructions before a 32 bit \emph{mov} and look at the value in the register to determine if the instruction could be replaced with its eight bit equivalent.

\chapter{Conclusion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliography{Bibliography}{}


%%%%%%%%%%%%%%%%%%
%\appendix
%%%%%%%%%%%%%%%%%%
%\chapter{Test Appendix}


\end{document}
